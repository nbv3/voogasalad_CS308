#VOOGASalad Design
##Syntactic Sugar
========

##Introduction
The purpose of this program is to implement a rudimentary game engine, so users can create simple 2D games and then subsequently play them. Our goal is to design a platform that is flexible enough to accommodate various versions of a single game genre, such that the user has the ability to easily generate a wide-range of possible games, without explicitly identifying what the game’s specific rules and configurations are. The game genre for our program is ‘Tower Defense’, the general goal of which is to allow the user to build a set of obstacles to block moving enemy characters from reaching a specific point. This basic design specification can easily be extended to generate hundreds of different games, which differ based on three basic parameters: map layout, characters (including enemies), and obstacles. Thus, our game engine will be malleable enough to accommodate any type of generated map, character, and obstacle that the user wants to implement for their custom ‘Tower Defense’ game.

The basic architecture of our program can be split up into the following general elements: game engine, game authoring environment, component hierarchy, and data structure, which together make up the entirety of the front- and back-end of our code. More specifically, the game authoring environment is responsible for handling the user interaction as well as generating the GUI components necessary to both create and play a game. On the other hand, the game engine is responsible for handling most of the back-end logic (i.e. defining whether the player can walk across a tile or not, based on its state) and is thus in two-way communication with the game authoring environment. Similarly, the component hierarchy defines the basic universal parameters that each possible version of ‘Tower Defense’ share, which are set by the user when creating a game and then subsequently updated when the game is being played. Hence, our program will be designed in a way, such that it is open to basic front-end extensions (i.e. accommodating new types of possible enemies), but closed to modification (i.e. the user can’t define a new component, since the component hierarchy is pre-defined and integral in implementing the back-end logic).

##Overview
The Syntactic Sugar game engine is a platform for developing 2-D grid-based games. This engine is designed to facilitate a grid-based game area upon which background objects can be placed, and in which characters and enemies can fluidly move from tile to tile. The primary goal for this project is to make an engine with which it is easy to make a tower defense game (with an interface that is intuitive for a designer as opposed to a developer or programmer), while still extending functionality to allow the creation of other grid-based games that may or may not fall into the category of tower defense (such as pac-man, or possibly even simple platformers/puzzle games).
In order to do this, the core game consists of two types of functionality extended to objects – a strongly defined hierarchy, which defines basic objects such as a tile or an enemy, and a dynamically compositional approach to less basic functionality, such as the property of having health or the property of applying some type of status effect. The hierarchy for game objects is programmed directly in, while the components, on the other hand, are a structure that consist of objects that may be added to or removed from an object at runtime, removing the need to explicitly define all the functionality that an object has in code. This allows the user to define in the editor a variety of functionality for an object, without having to do programming of their own, as they can implement an already extant general kind of functionality for an object simply by attaching a new component to it.

This rigid-soft dichotomy fits the needs of a grid-based game, such as a tower defense game, well. The engine will have to facilitate the creation of a general system where objects with variable functionality can be placed in predictable ways. Generally speaking, a tower must be placed on a tile, and it will affect the path that enemies will flow in a predictable way. However, the tower may have any combination of components that describe how it may have health, or do damage in a certain way, or apply some type of status effect. Therefore, using a hierarchy for the rigid types of interactions that a tower must handle, while dynamically adding functionality to the tower for the properties that the tower may or may not have, allows the user to add any combination of these properties to an object without writing new code. The same general logic applies to enemies, which must traverse the grid in some predictable way, but may have some combination of other properties, which each in themselves have defined functionality, but may or may not be attached to any particular object.
The Syntactic Sugar game engine is defined, generally speaking, for games that function like tower defense, providing functionality for grid-based movement, object spawning, and level change, in addition to modular functionality for some number of properties that these objects may have. However, the game engine will with these general properties ideally be able to handle a large variety of 2-D grid-based games that possess similarities to a tower defense game but do not fit in the genre. This extendability will provide a large amount of utility to this engine, allowing users to create a variety of games with the features that they desire.

##User Interface

The user will interact with the interface through a series of menu and game screens. The user interface will be presented based on the user’s selection of different modes. This explanation will demonstrate the user interactions related to the screens that are available. From the user’s standpoint, the game is represented in two forms. From a data and file standpoints, the game is represented by a single XML file that stores all of the game objects and preferences and even includes information about game state given that a certain level has been saved during game play. The game is also represented visually to the user during game play and game editing. Based on the game genres that we will be attempting to implement, the game will be represented by a series of tiles and objects on a grid representing a game map. In addition to the map on screen, there will be a visual queue into which the user can click and place enemies to spawn on screen in a certain order. While the game is being played, this map will represent the entire game play area with the exception of the menu where the player will be able to select towers to place on screen and be able to view resources such as money, power-ups, etc. If the user does not wish to create a game on the spot, there will be some default settings, maps, objects, and already designed games that can be automatically loaded into the game engine and played by any user.

While the game engine is loading, it will display a splash screen that will fade into the main menu (Image 1). Once the game engine loads, it will automatically direct the user to the main menu that will have options to play a game, go to the editor, go to the social center, or go to an HTML help page. When the user clicks on one of the options, the user will be directed to a new menu or page.

If the user selects the game player option, the user will be directed to a menu to select a game corresponding to an XML file from a drop down menu. Once a game has been selected, the user will be directed to another screen with the options to play the game from the first level for play from the last saved level. In addition, there will be options to set preferences, switch to the game editor, or go to the help screen. Selecting either of the play options will direct the user to the play screen where the user will see the level of the game being played along with a tab pane that will display towers and other objects that can be placed on screen during game play. The user will be able to click on the icon in the tab pane and then click on a location in the map to place the object. The map will have a snap-to-grid format so that each object takes up a single tile space.

If the user selects the game editor option, the user will be directed to an editor screen that divided in two parts. On the left hand side, an interactive map canvas will be displayed. The user will be able to populate the map with different tiles and monsters. The user will also be able to click buttons to add and delete levels and change levels in a drop down menu. On the right hand side, an object editor will allow the user to select from a library of default and created tiles, towers, and monsters and also be able to set preferences. The user will click on different tabs to see the different options for each category. Once the user feels that a level is complete, the user will be able to click a play button on the right hand side to directly open a game playing window associated with the game being designed at that moment. The user will also be able to save the current game and its levels to an XML file.

From the game editor pane, there will be a button, displayed with a + sign,  that allows the user to create custom towers, monsters, and tiles. Clicking this button will cause an object creator window to pop up. This will allow the user to create custom objects by setting a name, image, adding components, etc. These will all correspond to drop down menus, text input boxes, sliding bars, and other forms of user data input. In addition, it should be possible to set character movements based on key inputs. The user should be able to set these key values in the form of a single character or recognizable strings for buttons like “shift” to control the character.

If the user has uploaded a file that has bad data or incomplete data, this will be detected when the user selects a document after clicking the load button. If the parser is not able to directly parse the information and acquire all of its necessary information, it will throw an error and display an error pop-up with indicative error warnings without proceeding to the next screen so that the user is unable to continue with incomplete information.

![Image of Splash](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/Splash.png)
![Image of MainMenu](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/MainMenu.png)
![Image of GameSelect](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/GameSelect.png)
![Image of GameMenu](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/GameMenu.png)
![Image of GameEditor](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/GameEditor.png)
![Image of ObjectCreator](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/ObjectCreator.png)
